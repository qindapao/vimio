
     !   轻微          - 正在进行中             [bug] Bug               
    !!   一般优先级    o 待执行                 [req] Requirement       
   !!!   重要优先级    x 已经完成               [opt] Optimize
  !!!!   紧迫优先级    ~ 后续待讨论的内容       [tst] Test
                                                [ref] refactor
                                                [doc] Document
                                                [fil] File
                                                [fuc] Function

{id} 事项ID，按照按照添加时间顺序排列   
    vim命令自动传入当前buffer最大事项ID : `:VimioTodoId`
    vim命令查看当前 todo.txt 的大纲     : `:VimioTodoSummary`



o [fil]{0012}(!!!!) todo.vim
    o [req]{0013}(    ) 增加一个功能更新父节点的优先级，取缩进的子节点中的最高优先级。普通模式下操作即可。
                        并且要根据下面的子节点的任务完成情况(- o x)的情况更新标头。
                        父节点的优先级和状态不应该手动更新，都应该由子节点的状态来决定
    o [req]{0028}(    ) `highlight` 高亮功能
                        类似于这样的反引号包裹的字符串在文本中高亮显示出来
    o [req]{0029}(    ) `todo.vim` 独立成一个独立的插件，不要包含在 `vimio` 插件中。
    o [req]{0030}(    ) 超链接和锚点
                        当前 `todo.txt` 中可以标记锚点，让可以方便跳转。超链接标记用于跳转到锚点。
                        当前节点的 `Id` 为天然的双向锚点。可以在文本中循环跳转。跳转后更新 `vim` 的位置列表，这样可以方
                        便跳回。
    o [req]{0042}(    ) 增加一个功能，当用户使用 `VimioTodoId` 插入一个节点 `Id` 的时候，自动在文件的末尾的区域插入这个
                        Id 生成的时间节点。甚至可以补充一些 `备忘` 信息之类的。
    o [req]{0044}(    ) 使用 <{}> 标记的内容是一个超级链接，支持使用 `vim` 直接打开浏览器。具体的 `tag` 格式可以再决定。
    x [bug]{0045}(    ) 当前的高亮 `Id` 的管理有问题，频繁触发BUG。
    o [req]{0048}(    ) 使用一种特殊的方法，文件后缀？来识别我们的格式的文件，然后增加可以折叠已经完成的项目的功能。
                        (标 x 的项目，也可以显示它们，用户可以切换)
    o [req]{0064}(    ) 任务可以设置开始时间和结束时间。并且可以设置每个任务快到期前多久开始vim的非干扰小弹窗提醒。

x [fil]{0011}(!!!!) replace.vim
    x [fuc]{0014}(!!!!) vimio#replace#paste_block_clip
        x [bug]{0003}(!!!!) 如果覆盖层的右边界恰好在被覆盖的文本的某个双宽字符的左半槽上面，覆盖后会少一个空格，导致整体
                            内容左移，英文覆盖中文的情况下也是错乱的。


x [fil]{0015}(    ) debug.vim
    x [fuc]{0016}(    ) vimio#debug#pretty_print
        x [req]{0001}(    ) 打印出来的键并没有顺序，不便于问题定位   
    x [req]{0002}(    ) 可以做一个两个对象的对比功能，先把两个嵌套的对象都树状打印字符串化，然后对比两个数据结构的具体差
                        异，并且清晰显示出来

x [fil]{0017}(    ) cursors.vim
    x [fuc]{0018}(    ) vimio#cursor#vhl_add_points_and_apply
        x [bug]{0004}(    ) 某些情况下上报，找不到 ID: 1536 之类的。
                            原因：在A buffer生成了高亮，没有清理。然后在B buffer执行高亮。

o [fil]{0019}(   !) shapes/box.vim
    o [req]{0005}(   !) 高亮选择边框后改变边框类型的功能。可以使用一个快捷键进行周期性切换，减少快捷键的数量。
                        高亮选择后批量替换对应的框字符为需要切换的系列(ASCII/unicode/unicode bold ...)。也可以按照路径绘
                        制，这样可以自动处理交叉处的字符。暴力替换字符是没有办法处理交叉点字符。
                        需要切换的字符集由光标处的字符的字符集类型决定。
                        判断的时候需要排除空格点的干扰。
    o [req]{0068}(    ) 针对每一种类型的盒子，切换边框类型执行后都要记住最后一次的边框类型。所有的形状的边框索引都必须一
                        致。还可以选择一个图形后可以捕捉当前的边框类型索引。然后就可以方便的改变另外一个形状的类型。
    x [req]{0038}(    ) 预览剪切板中的图形，并且补齐交叉字符。
    o [req]{0039}(    ) 识别光标下的矩形盒子边框，并且让它智能的变大和缩小。
    o [req]{0069}(    ) resize可以考虑支持4个方向的，当前只能右下角。


x [fil]{0020}(    ) drawline.vim
    x [req]{0007}(    ) 智能线绘制   
    x [req]{0008}(    ) 高亮选择线后改变线的类型功能，和 {0005} 功能相似。
    x [req]{0040}(    ) 智能识别当前光标下的线条，然后重新调整它的位置和大小。光标离一端近的作为起点，另外一端作为终点。
    x [req]{0059}(    ) 线段从某个点破开，然后操作一个终点和两个起点，同时调整位置。(还有别的类似的联动操作)。
                        如果想要操作多起点，可以考虑使用高亮来标记多个起点。
    x [req]{0063}(    ) 最好是录一个小视频说明下智能线的使用方法，还有其它操作也建议录制一个小视频。

o [fil]{0021}(   !) vimio.txt
    o [doc]{0006}(   !) 智能选择模式的所有操作详细说明。


o [fil]{0022}(   !) cursors.vim
    o [bug]{0009}(   !) 如果当前光标在虚拟编辑模式下的不存在空格的位置，无法进行高亮。影响我们后面的新特性智能线起点标记
                        功能。

~ [fil]{0023}(   !) draw.vim
    ~ [bug]{0010}(    ) 横向和纵向绘线，对于起点的前面一个点不应该进行交叉字符的判断和改变，始终应该保持它自己，不应该做
                        特殊处理。
                        |               |               |
                        |A    B         .------         |------
                        |               |               |

                        A  to  B        wrong           right

                        如果想生成 wrong 处那样的图形，起点应该是下面这样
                        |      
                        A     B
                        |      

                        Note:   这个 `bug` 当前没有办法修复，因为在一个绘图上下文中，只有一个点，每个点都是起点。
                                其实当前可以这样规避:
                                    如果起点可能发生交叉，那么在起点的前一个字符开始绘制。
                                

o [fil]{0025}(!!!!) select.vim
    - [req]{0026}(!!!!) 所有的基于fill-flood算法和环算法的快捷选择算法的反向选择功能。
    o [bug]{0031}(  !!) A是行末点，执行 vimio#select#line_select 出现错误，将列表作字符串使用
                        |
                        | .----.-------.                        
                        | |    |       |                        
                        | |    |       '--------------.        A
                        | '----'-------'              |        |
                        |                             |        |
                        |                             |        |
                        | .----.-------.              |        |
                        | |    |       |              |        v
                        | |    |       '--------------+---------
                        | '----'-------'                        
    x [ref]{0032}(    ) 目前取最大环(vimio#select#highlight_inside_border)效率极其低下，可以考虑用
                        vimio#select#extract_all_closed_loops 找到所有闭合环，然后筛选出经过当前点
                        的，然后再从里面筛选出路径最长的环。
                        暂时不实现，使用 vimio#select#highlight_inside_line 暂时替代。
    x [req]{0049}(    ) 增加一个实心块文本选择模式，排除所有的交点字符，选择纯文本。

o [ref]{0024}(   !) 所有的代码中哪些函数变量应该是全局哪些应该是局部，还有变量管理要清理一遍。
o [ref]{0027}(   !) 所有的函数都应该加 `abort` 标签。
o [req]{0033}(    ) 镜像功能。指定需要镜像的高亮区域，指定镜像轴，可以是水平或者垂直或者旋转。指定每个绘图字符对应的镜像
                    字符。
o [ref]{0034}(    ) 当前单字符的行获取还是用的正则高效版本，如果字符集超出范围可能有BUG。后续可以考虑采用
                    strdisplaywidth 版本(不考虑长行性能问题)
o [doc]{0035}(    ) 写一个 `for_develep` 的文档

o [fil]{0036}(    ) basic.vim
    o [req]{0037}(    ) basic.vim 增加各种矩形盒子，以便用户方便插入。还有其它常见的盒子(*和oO等等)。然后字符集也需要同
                        步更新
x [req]{0041}(    ) 图形集的预览的功能的增强
o [req]{0043}(    ) 这里有一种特殊的商用字体 `https://github.com/fabrizioschiavi/pragmatapro` (可惜是商用字体，无法开源
                    使用)。这个字体的神奇之处是它的自定义区域有很多绘图字符，可以让斜线和直线连接无空隙。可以考虑通过这
                    种字体可以设计超级交叉模式，可以绘制更加美观的待斜线的图形(支持8个方向的交叉字符)。

o [tst]{0046}(    ) 终端 `vim` 下的全量验证。
o [req]{0047}(    ) 对 `neovim` 的支持考虑。
x [req]{0050}(    ) 智能删除，删除后自动补齐因为删除导致的边框缺失字符。
x [req]{0051}(    ) 选择一个高亮的文本区域(使用高亮选择，不要用可视块模式)，外围绕一个盒子边框。
o [req]{0052}(    ) 智能图形绘制。
    o [req]{0053}(    ) 绘制智能圆，对称圆和非对称圆都可以实现。
    x [req]{0056}(    ) 绘制智能矩形。
    o [req]{0057}(    ) 绘制可以灵活调整大小的其它智能形状。
    x [req]{0055}(    ) 光标放置到图形边框上主动识别盒子类型然后可以变大缩小。盒子线型由当前全局线型决定。鼠标滚轮可以设
                        置为预览图形类型。奇怪形状的线型也统一切换。
o [req]{0054}(    ) zim或者markdown等等的修饰模式支持。高亮下划线链接等等。
x [req]{0058}(    ) 使用弹出窗口实现对齐线(hint line)功能，建议使用独立的弹出窗口来实现，不要复用当前的全局弹出窗口。

x [fil]{0060}(    ) shapes.vim
    x [req]{0061}(    ) 用快捷键加预览的方式显示模板的速度更快，免得用户频繁的在预览中切换。

x [req]{0062}(    ) 表格编辑。可以方便的插入行列，或者删除行列，等等。或者改变每个单元格的边框风格等等。还有移动行列等等
    x[req]{0065}(    )  删除表格线有6种情况(上下左右边框，内部的横和竖)，非常好分类.
    x[req]{0066}(    )  增加行和列也一样是分6种情况。
    x[req]{0067}(    )  表格删除和增加的时候，因为操作导致的其它线段缺失需要补充上。如果是外边框删除，那么删除后导致多余
                        出来的线段也要处理
    x[req]{0071}(    )  表格行的内部增加一行，并不产生新的行，表格列的内部增加一列，并不产生新的列。
    x[req]{0072}(    )  表格的操作直接把光标放到对应的框线上就能进行，并不需要高亮。使用算法自动识别行或者列区域，使用类
                        似 flood_fill 的算法。
    x[req]{0073}(    )  要想实现高效的表格，可能不能使用对象管理的方式，这样每次重绘表格非常慢。可以考虑采用捕捉近邻的行
                        或者列，然后吧表格基于 flood_fill 算法之类的分成几个部分，然后插入行列或者删除行列，然后再和这些
                        部分重新组合即可。如果基于对象重新生成表格，太慢了，不适合！
o [req]{0070}(    ) 艺术字编辑模式。可以切换艺术字的字体，然后在艺术字模式下，可以通过键盘方便输入。
x [bug]{0074}(    ) 切换主题后，当前插件中的所有高亮组定义都会丢失。建议增加保护措施。
o [req]{0075}(    ) 创建一种 DSL 描述语言，通过 DSL 代码生成自动布局的文本流程图。渲染的速度可能是个问题，需要使用高效的
                    算法。

