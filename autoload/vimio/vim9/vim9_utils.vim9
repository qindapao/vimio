vim9script

def BuildPreviewChars(text_lines: list<string>, cross_enable: bool, pos_start: list<number>): dict<any>
    var min_row = pos_start[0]
    var min_col = pos_start[1]
    var max_row = min_row + text_lines->len() - 1
    var max_col = min_col + text_lines->copy()->map((_, val) => strdisplaywidth(val))->max() - 1

    var rect_opts = {
        min_row: min_row,
        max_row: max_row,
        min_col: min_col,
        max_col: max_col,
        rect: [],
        rect_cross_chars: {},
    }

    var rect = []
    var rect_cross_chars = {}
    var blank_row = repeat([' '], max_col - min_col + 1)

    for _ in range(min_row, max_row)
        rect->add(blank_row->copy())
    endfor

    var row = min_row
    for line in text_lines
        var col = min_col
        var row_offset = row - min_row

        for char in split(line, '\zs')
            var width = strdisplaywidth(char)
            rect[row_offset][col - min_col] = char

            if cross_enable
                rect_cross_chars[row .. ',' .. col] = char
            endif

            if width == 2
                rect[row_offset][col + 1 - min_col] = ''
            endif

            col += width
        endfor
        row += 1
    endfor

    rect_opts.rect = rect
    rect_opts.rect_cross_chars = rect_cross_chars
    return rect_opts
enddef

def MergeSparseValues(dict1: dict<string>, dict2: dict<string>, pop_up_type: string): dict<list<string>>
    var result: dict<list<string>> = {}

    # First, add all the key-value pairs from dict1.
    for key in keys(dict1)
        if has_key(g:vimio_config_draw_cross_chars, dict1[key])
            result[key] = [dict1[key]]
        endif
    endfor

    # Only merge the keys in dict2 that are not present in dict1.
    if g:vimio_config_cross_algorithm == 'multi'
        for key in keys(dict2)
            if pop_up_type == 'cover' && has_key(dict1, key)
                continue
            endif
            result[key] = get(result, key, [])
            result[key]->add(dict2[key])
        endfor
    else
        for key in keys(dict2)
            if !has_key(dict1, key)
                result[key] = [dict2[key]]
            else
                if pop_up_type == 'overlay' && dict1[key] == ' '
                    result[key] = [dict2[key]]
                endif
            endif
        endfor
    endif

    return result
enddef


def GetSparseIntersections(dict1: dict<string>, dict2: dict<string>): dict<list<string>>
    var result: dict<list<string>> = {}

    for key in keys(dict1)
        if has_key(dict2, key) && dict1[key] != ' '
            result[key] = [dict1[key], dict2[key]]
        endif
    endfor

    return result
enddef

export def GetDoublewidthCols(row: number, ...args: list<any>): list<number>
    var cols: list<number> = []
    var col = 1
    var line = get(args, 0, getline(row))
    var len = len(line)

    var pattern = g:vimio_doublewidth_pattern

    while col <= len
        var pos = matchstrpos(line, pattern, col - 1)
        if empty(pos) || pos[1] == -1
            break
        endif

        call add(cols, virtcol([row, pos[1] + 1]))
        col = pos[1] + 3
    endwhile

    return cols
enddef

# :TODO: There are two ways to implement it, refer to
#   vimio#utils#get_doublewidth_cols_old fast but Requires follow-up maintenance
#   vimio#utils#get_doublewidth_cols_new slow but no subsequent maintenance required
#   Use the first implementation for speed
def GetLineCellsInsertDoubleChar(row: number, ...args: list<any>): list<any>
    if row < 1 || row > line('$')
        return [[], 0]
    endif

    var lineStr = getline(row)
    var phyCol = get(args, 0, virtcol('.'))

    var realPhyWidth = virtcol([row, '$']) - 1
    var maxWidth = max([phyCol, realPhyWidth])

    var lineCharsArray = split(lineStr, '\zs')

    for insertIndex in GetDoublewidthCols(row, lineStr)
        call insert(lineCharsArray, '', insertIndex - 1)
    endfor

    call extend(lineCharsArray, repeat([' '], maxWidth - realPhyWidth))
    return [lineCharsArray, phyCol - 1]
enddef


def GetEditorRect(pos: list<number>, width: number, height: number, isJustCrossChar: bool): dict<string>
    var startRow = pos[0]
    var startCol = pos[1]
    var result: dict<string> = {}

    var lastLine = line('$')
    var endRow = startRow + height - 1
    var endCol = startCol + width - 1
    var endCol_1 = startCol + width 

    for row in range(startRow, endRow)
        if row > lastLine
            break
        endif

        var [chars, _] = GetLineCellsInsertDoubleChar(row, endCol_1)
        for col in range(startCol, endCol)
            var ch = chars[col - 1]
            if isJustCrossChar && !has_key(g:vimio_config_draw_cross_chars, ch)
                continue
            endif
            result[string(row) .. ',' .. string(col)] = ch
        endfor
    endfor

    return result
enddef

def GetRectTxtForSingleWidthChar(
        preview_text: list<list<any>>,
        cross_enable: bool,
        pos: list<number>,
        pop_up_type: string,
        ...opts_list: list<dict<any>>
        ): string
    var opts = get(opts_list, 0, {})
    var rect: list<list<string>>
    var rect_cross_chars: dict<string>
    var min_row: number
    var max_row: number
    var min_col: number
    var max_col: number

    if !empty(opts)
        rect = opts.rect
        rect_cross_chars = opts.rect_cross_chars
        min_row = opts.min_row
        max_row = opts.max_row
        min_col = opts.min_col
        max_col = opts.max_col
    else
        var rows = copy(preview_text)->map((_, v) => v[0])
        var cols = copy(preview_text)->map((_, v) => v[1])
        min_row = min(rows)
        max_row = max(rows)
        min_col = min(cols)
        max_col = max(cols)

        rect = []
        rect_cross_chars = {}
        var blank_row = repeat([' '], max_col - min_col + 1)
        for _ in range(min_row, max_row)
            rect->add(blank_row->copy())
        endfor

        for item in preview_text
            var [row, col, ch] = item
            rect[row - min_row][col - min_col] = ch
            if cross_enable
                rect_cross_chars[row .. ',' .. col] = ch
            endif
        endfor
    endif

    # var t1: any
    # var t2: any
    # var t3: any
    # var t4: any
    # var t5: any
    # var t6: any
    # var t7: any

    if cross_enable
        # t1 = reltime()
        var [pos_row, pos_col] = pos
        var min_row_ext = max([pos_row - 1, 1])
        var max_row_ext = min([pos_row + (max_row - min_row) + 1, line('$')])
        var min_col_ext = max([pos_col - 1, 1])
        var max_col_ext = pos_col + (max_col - min_col) + 1

        var editor_chars = GetEditorRect(
            [min_row_ext, min_col_ext],
            max_col_ext - min_col_ext + 2,
            max_row_ext - min_row_ext + 2,
            true
        )
        # t2 = reltime()

        var all_chars = MergeSparseValues(rect_cross_chars, editor_chars, pop_up_type)
        # t3 = reltime()
        var cross_point = GetSparseIntersections(rect_cross_chars, editor_chars)
        # t4 = reltime()
        var cross_chars: dict<string> = vimio#scene#get_cross_chars(cross_point, all_chars)
        # t5 = reltime()

        # call vimio#debug#log_obj("rect_cross_chars", rect_cross_chars, 4, '')
        # call vimio#debug#log_obj("editor_chars", editor_chars, 4, '')
        # call vimio#debug#log_obj("all_chars", all_chars, 4, '')
        # call vimio#debug#log_obj("cross_point", cross_point, 4, '')
        # call vimio#debug#log_obj("cross_chars", cross_chars, 4, '')
    
        for [key, ch] in items(cross_chars)
            var [r, c] = split(key, ',')->map('str2nr(v:val)')
            rect[r - min_row][c - min_col] = ch
        endfor
        # t6 = reltime()
    endif

    # For each line, first use map() to convert each character ch into a string.
    # Then join() it into a single line of text.
    # Ultimately, it remains a `list<string>`, but type inference will no longer result in an error.
    var lines: list<string> = []
    for line in rect
        lines->add(join(line, ''))
    endfor
    # t7 = reltime()
    # call vimio#debug#log(
    #             "get_editor_rect: %.2f;"
    #             .. "MergeSparseValues: %.2f;"
    #             .. "GetSparseIntersections: %.2f;"
    #             .. "get_cross_chars: %.2f;"
    #             .. "rect: %.2f;"
    #             .. "lines: %.2f;",
    #             vimio#debug#time_ms(t1, t2),
    #             vimio#debug#time_ms(t2, t3),
    #             vimio#debug#time_ms(t3, t4),
    #             vimio#debug#time_ms(t4, t5),
    #             vimio#debug#time_ms(t5, t6),
    #             vimio#debug#time_ms(t6, t7)
    #             )

    return join(lines, "\n")
enddef


g:Vimio_BuildPreviewCharsFunc = BuildPreviewChars
g:Vimio_GetRectTxtForSingleWidthCharFunc = GetRectTxtForSingleWidthChar
g:Vimio_GetLineCellsFunc = GetLineCellsInsertDoubleChar

